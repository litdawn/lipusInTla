{"location":"line 1, col 1 to line 176, col 77 of module MongoStaticRaft","moduleInfo":{"location":"line 1, col 1 to line 1, col 32 of module MongoStaticRaft","moduleName":"MongoStaticRaft"},"extends":{"extendedModuleNames":["Naturals","Integers","FiniteSets","Sequences","TLC"],"location":"line 6, col 1 to line 6, col 54 of module MongoStaticRaft"},"body":{"declaredParams":[{"location":"line 8, col 1 to line 8, col 16 of module MongoStaticRaft","paramName":"Server"},{"location":"line 9, col 1 to line 9, col 33 of module MongoStaticRaft","paramName":"Secondary"},{"location":"line 10, col 1 to line 10, col 17 of module MongoStaticRaft","paramName":"InitTerm"}],"definedVariables":[{"variableName":"currentTerm"},{"variableName":"state"},{"variableName":"log"},{"variableName":"committed"}],"location":"line 8, col 1 to line 174, col 29 of module MongoStaticRaft","operatorDefinitions":[{"concreteContent":"vars == <<currentTerm, state, log, committed>>","location":"line 17, col 1 to line 17, col 46 of module MongoStaticRaft","operatorName":"vars","type":"State"},{"concreteContent":"Empty(s) == Len(s) = 0","location":"line 24, col 1 to line 24, col 22 of module MongoStaticRaft","operatorName":"Empty","paramNum":1,"type":"Action"},{"concreteContent":"InLog(e, i) == \\E x \\in DOMAIN log[i] : x = e[1] /\\ log[i][x] = e[2]","location":"line 27, col 1 to line 27, col 68 of module MongoStaticRaft","operatorName":"InLog","paramNum":2,"type":"Action"},{"concreteContent":"LastTerm(xlog) == IF Len(xlog) = 0 THEN 0 ELSE xlog[Len(xlog)]","location":"line 30, col 1 to line 30, col 62 of module MongoStaticRaft","operatorName":"LastTerm","paramNum":1,"type":"Action"},{"concreteContent":"LastEntry(xlog) == <<Len(xlog),xlog[Len(xlog)]>>","location":"line 31, col 1 to line 31, col 48 of module MongoStaticRaft","operatorName":"LastEntry","paramNum":1,"type":"Action"},{"concreteContent":"GetTerm(xlog, index) == IF index = 0 THEN 0 ELSE xlog[index]","location":"line 32, col 1 to line 32, col 60 of module MongoStaticRaft","operatorName":"GetTerm","paramNum":2,"type":"Action"},{"concreteContent":"LogTerm(i, index) == GetTerm(log[i], index)","location":"line 33, col 1 to line 33, col 43 of module MongoStaticRaft","operatorName":"LogTerm","paramNum":2,"type":"Action"},{"concreteContent":"Quorums(S) == {i \\in SUBSET(S) : Cardinality(i) * 2 > Cardinality(S)}","location":"line 36, col 1 to line 36, col 69 of module MongoStaticRaft","operatorName":"Quorums","paramNum":1,"type":"Action"},{"concreteContent":"CanRollback(i, j) ==\n    /\\ Len(log[i]) > 0\n    /\\ \\* The log with later term is more up-to-date.\n       LastTerm(log[i]) < LastTerm(log[j])\n    /\\ \\/ Len(log[i]) > Len(log[j])\n       \\* There seems no short-cut of OR clauses, so we specify the negative case.\n       \\/ /\\ Len(log[i]) <= Len(log[j])\n          /\\ LastTerm(log[i]) /= LogTerm(j, Len(log[i]))\n","location":"line 40, col 1 to line 47, col 56 of module MongoStaticRaft","operatorName":"CanRollback","paramNum":2,"type":"Action"},{"concreteContent":"CanVoteForOplog(i, j, term) ==\n    LET logOk ==\n        \\/ LastTerm(log[j]) > LastTerm(log[i])\n        \\/ /\\ LastTerm(log[j]) = LastTerm(log[i])\n           /\\ Len(log[j]) >= Len(log[i]) IN\n    /\\ currentTerm[i] < term\n    /\\ logOk\n","location":"line 50, col 1 to line 56, col 12 of module MongoStaticRaft","operatorName":"CanVoteForOplog","paramNum":3,"type":"Action"},{"concreteContent":"ImmediatelyCommitted(e, Q) == \n    LET eind == e[1] \n        eterm == e[2] IN\n    \\A s \\in Q :\n        /\\ Len(log[s]) >= eind\n        /\\ InLog(e, s) \\* they have the entry.\n        /\\ currentTerm[s] = eterm\n","location":"line 59, col 1 to line 65, col 33 of module MongoStaticRaft","operatorName":"ImmediatelyCommitted","paramNum":2,"type":"Action"},{"concreteContent":"UpdateTermsExpr(i, j) ==\n    /\\ currentTerm[i] > currentTerm[j]\n    /\\ currentTerm' = [currentTerm EXCEPT ![j] = currentTerm[i]]\n    /\\ state' = [state EXCEPT ![j] = Secondary]\n","location":"line 68, col 1 to line 71, col 47 of module MongoStaticRaft","operatorName":"UpdateTermsExpr","paramNum":2,"type":"Action"},{"concreteContent":"ClientRequest(i) ==\n    /\\ state[i] = Primary\n    /\\ log' = [log EXCEPT ![i] = Append(log[i], currentTerm[i])]\n    /\\ UNCHANGED <<currentTerm, state, committed>>\n","location":"line 81, col 1 to line 84, col 50 of module MongoStaticRaft","operatorName":"ClientRequest","paramNum":1,"type":"Action"},{"concreteContent":"GetEntries(i, j) ==\n    /\\ state[i] = Secondary\n    \\* Node j must have more entries than node i.\n    /\\ Len(log[j]) > Len(log[i])\n       \\* Ensure that the entry at the last index of node i's log must match the entry at\n       \\* the same index in node j's log. If the log of node i is empty, then the check\n       \\* trivially passes. This is the essential 'log consistency check'.\n    /\\ LET logOk == IF Empty(log[i])\n                        THEN TRUE\n                        ELSE log[j][Len(log[i])] = log[i][Len(log[i])] IN\n       /\\ logOk \\* log consistency check\n       \\* If the log of node i is empty, then take the first entry from node j's log.\n       \\* Otherwise take the entry following the last index of node i.\n       /\\ LET newEntryIndex == IF Empty(log[i]) THEN 1 ELSE Len(log[i]) + 1\n              newEntry      == log[j][newEntryIndex]\n              newLog        == Append(log[i], newEntry) IN\n              /\\ log' = [log EXCEPT ![i] = newLog]\n    /\\ UNCHANGED <<committed, currentTerm, state>>\n","location":"line 87, col 1 to line 104, col 50 of module MongoStaticRaft","operatorName":"GetEntries","paramNum":2,"type":"Action"},{"concreteContent":"RollbackEntries(i, j) ==\n    /\\ state[i] = Secondary\n    /\\ CanRollback(i, j)\n    \\* Roll back one log entry.\n    /\\ log' = [log EXCEPT ![i] = SubSeq(log[i], 1, Len(log[i])-1)]\n    /\\ UNCHANGED <<committed, currentTerm, state>>\n","location":"line 107, col 1 to line 112, col 50 of module MongoStaticRaft","operatorName":"RollbackEntries","paramNum":2,"type":"Action"},{"concreteContent":"BecomeLeader(i, voteQuorum) == \n    \\* Primaries make decisions based on their current configuration.\n    LET newTerm == currentTerm[i] + 1 IN\n    /\\ i \\in voteQuorum \\* The new leader should vote for itself.\n    /\\ \\A v \\in voteQuorum : CanVoteForOplog(v, i, newTerm)\n    \\* Update the terms of each voter.\n    /\\ currentTerm' = [s \\in Server |-> IF s \\in voteQuorum THEN newTerm ELSE currentTerm[s]]\n    /\\ state' = [s \\in Server |->\n                    IF s = i THEN Primary\n                    ELSE IF s \\in voteQuorum THEN Secondary \\* All voters should revert to secondary state.\n                    ELSE state[s]]\n    /\\ UNCHANGED <<log, committed>>\n","location":"line 115, col 1 to line 126, col 35 of module MongoStaticRaft","operatorName":"BecomeLeader","paramNum":2,"type":"Action"},{"concreteContent":"CommitEntry(i, commitQuorum) ==\n    LET ind == Len(log[i]) IN\n    \\* Must have some entries to commit.\n    /\\ ind > 0\n    \\* This node is leader.\n    /\\ state[i] = Primary\n    \\* The entry was written by this leader.\n    /\\ log[i][ind] = currentTerm[i]\n    \\* all nodes have this log entry and are in the term of the leader.\n    /\\ ImmediatelyCommitted(<<ind,currentTerm[i]>>, commitQuorum)\n    \\* Don't mark an entry as committed more than once.\n    /\\ ~\\E c \\in committed : c.entry = <<ind, currentTerm[i]>>\n    /\\ committed' = committed \\cup\n            {[ entry  |-> <<ind, currentTerm[i]>>,\n               term  |-> currentTerm[i]]}\n    /\\ UNCHANGED <<currentTerm, state, log>>\n","location":"line 129, col 1 to line 144, col 44 of module MongoStaticRaft","operatorName":"CommitEntry","paramNum":2,"type":"Action"},{"concreteContent":"UpdateTerms(i, j) == \n    /\\ UpdateTermsExpr(i, j)\n    /\\ UNCHANGED <<log, committed>>\n","location":"line 151, col 1 to line 153, col 35 of module MongoStaticRaft","operatorName":"UpdateTerms","paramNum":2,"type":"Action"},{"concreteContent":"Init == \n    /\\ currentTerm = [i \\in Server |-> InitTerm]\n    /\\ state       = [i \\in Server |-> Secondary]\n    /\\ log = [i \\in Server |-> <<>>]\n    /\\ committed = {}\n","location":"line 155, col 1 to line 159, col 21 of module MongoStaticRaft","operatorName":"Init","type":"State"},{"concreteContent":"ClientRequestAction == \\E s \\in Server : ClientRequest(s)","location":"line 161, col 1 to line 161, col 57 of module MongoStaticRaft","operatorName":"ClientRequestAction","type":"State"},{"concreteContent":"GetEntriesAction == \\E s, t \\in Server : GetEntries(s, t)","location":"line 162, col 1 to line 162, col 57 of module MongoStaticRaft","operatorName":"GetEntriesAction","type":"State"},{"concreteContent":"RollbackEntriesAction == \\E s, t \\in Server : RollbackEntries(s, t)","location":"line 163, col 1 to line 163, col 67 of module MongoStaticRaft","operatorName":"RollbackEntriesAction","type":"State"},{"concreteContent":"BecomeLeaderAction == \\E s \\in Server : \\E Q \\in Quorums(Server) : BecomeLeader(s, Q)","location":"line 164, col 1 to line 164, col 85 of module MongoStaticRaft","operatorName":"BecomeLeaderAction","type":"State"},{"concreteContent":"UpdateTermsActions == \\E s,t \\in Server : UpdateTerms(s, t)","location":"line 165, col 1 to line 165, col 59 of module MongoStaticRaft","operatorName":"UpdateTermsActions","type":"State"},{"concreteContent":"Next == \n    \\/ ClientRequestAction\n    \\/ GetEntriesAction\n    \\/ RollbackEntriesAction\n    \\/ BecomeLeaderAction\n    \\/ UpdateTermsActions\n","location":"line 167, col 1 to line 172, col 25 of module MongoStaticRaft","operatorName":"Next","type":"State"},{"concreteContent":"Spec == Init /\\ [][Next]_vars","location":"line 174, col 1 to line 174, col 29 of module MongoStaticRaft","operatorName":"Spec","type":"State"}]}}